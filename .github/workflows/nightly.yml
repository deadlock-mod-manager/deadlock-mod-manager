name: Nightly Build

env:
  NODE_VERSION: "24.8.0"
  ENABLE_SIGNED_UPDATER: "false"

on:
  # schedule:
  #   # Run at 2 AM UTC every day
  #   - cron: "0 2 * * *"
  workflow_dispatch: # Allow manual triggering
    inputs:
      build_windows:
        description: "Build for Windows"
        type: boolean
        default: true
      build_linux:
        description: "Build for Linux"
        type: boolean
        default: true

jobs:
  check-commits:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      commit_count: ${{ steps.check.outputs.commit_count }}
      latest_commit: ${{ steps.check.outputs.latest_commit }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for new commits since last nightly
        id: check
        run: |
          # Get the latest nightly release tag
          LAST_NIGHTLY=$(git tag -l "nightly-*" --sort=-version:refname | head -1)

          if [ -z "$LAST_NIGHTLY" ]; then
            echo "No previous nightly build found, will build"
            COMMIT_COUNT=$(git rev-list --count HEAD)
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "Last nightly: $LAST_NIGHTLY"
            LAST_NIGHTLY_COMMIT=$(git rev-list -n 1 $LAST_NIGHTLY)
            COMMIT_COUNT=$(git rev-list --count ${LAST_NIGHTLY_COMMIT}..HEAD)
            
            if [ $COMMIT_COUNT -gt 0 ]; then
              echo "Found $COMMIT_COUNT new commits since last nightly"
              echo "should_build=true" >> $GITHUB_OUTPUT
            else
              echo "No new commits since last nightly"
              echo "should_build=false" >> $GITHUB_OUTPUT
            fi
          fi

          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          echo "latest_commit=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

  prepare-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Prepare build matrix
        id: set-matrix
        run: |
          # For scheduled runs, build all platforms
          if [ "${{ github.event_name }}" = "schedule" ]; then
            matrix='{"platform":["windows-latest","ubuntu-24.04"]}'
          else
            # For manual dispatch, build based on inputs
            platforms=""
            
            if [ "${{ inputs.build_windows }}" = "true" ]; then
              platforms="windows-latest"
            fi
            
            if [ "${{ inputs.build_linux }}" = "true" ]; then
              if [ -z "$platforms" ]; then
                platforms="ubuntu-24.04"
              else
                platforms="$platforms,ubuntu-24.04"
              fi
            fi
            
            # If no platforms selected, default to all
            if [ -z "$platforms" ]; then
              platforms="windows-latest,ubuntu-24.04"
            fi
            
            # Convert to JSON array
            matrix=$(echo "$platforms" | jq -Rc 'split(",") | {platform: .}')
          fi

          echo "matrix=$matrix" >> $GITHUB_OUTPUT
          echo "Selected platforms: $matrix"

  create-nightly-release:
    needs: check-commits
    if: needs.check-commits.outputs.should_build == 'true'
    permissions:
      contents: write
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create-release.outputs.result }}
      tag_name: ${{ steps.create-release.outputs.tag_name }}
      package_version: ${{ steps.version.outputs.package_version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js environment
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache-dependency-path: pnpm-lock.yaml

      - uses: pnpm/action-setup@v4

      - name: Get version and create tag
        id: version
        run: |
          PACKAGE_VERSION=$(node -p "require('./apps/desktop/package.json').version")
          DATE=$(date +%Y%m%d)
          COMMIT_SHORT=${{ needs.check-commits.outputs.latest_commit }}
          TAG_NAME="nightly-${PACKAGE_VERSION}-${DATE}-${COMMIT_SHORT}"
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "PACKAGE_VERSION=$PACKAGE_VERSION" >> $GITHUB_ENV
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_ENV

      - name: Get last nightly tag
        id: last-nightly
        run: |
          LAST_NIGHTLY=$(git tag -l "nightly-*" --sort=-version:refname | head -1)
          echo "last_nightly=$LAST_NIGHTLY" >> $GITHUB_OUTPUT
          echo "Last nightly tag: $LAST_NIGHTLY"

      - name: Generate commit list
        id: commits
        run: |
          if [ -n "${{ steps.last-nightly.outputs.last_nightly }}" ]; then
            COMMIT_RANGE="${{ steps.last-nightly.outputs.last_nightly }}..HEAD"
          else
            COMMIT_RANGE="HEAD"
          fi

          COMMIT_LIST=$(git log $COMMIT_RANGE --pretty=format:"- %s (%h)" --no-merges)

          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_LIST" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create nightly release
        id: create-release
        uses: actions/github-script@v7
        env:
          COMMITS: ${{ steps.commits.outputs.commits }}
        with:
          script: |
            const tag = process.env.TAG_NAME;
            const commitCount = ${{ needs.check-commits.outputs.commit_count }};
            const commits = process.env.COMMITS;

            console.log(`Creating nightly release: ${tag}`);

            const releaseBody = [
              "**Nightly build from latest development**",
              "",
              `Built: ${new Date().toISOString().split('T')[0]}`,
              `Commits since last nightly: ${commitCount}`,
              `Latest Commit: ${context.sha.substring(0, 7)}`,
              "",
              "**Warning:** This is a nightly build and may contain unstable features or bugs.",
              "",
              "## Changes in this nightly build",
              "",
              commits || "No commits found",
              "",
              "---",
              "*This release was generated automatically from the latest development branch.*"
            ].join('\n');

            const { data } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tag,
              name: `Nightly ${tag}`,
              body: releaseBody,
              draft: true,
              prerelease: true
            });

            console.log(`Release created with ID: ${data.id}`);
            console.log(`Release URL: ${data.html_url}`);

            // Verify the release was created successfully
            const { data: verifyRelease } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: data.id
            });

            if (!verifyRelease || verifyRelease.id !== data.id) {
              throw new Error(`Failed to verify release creation. Expected ID ${data.id}, got ${verifyRelease?.id}`);
            }

            console.log(`Release verified: ${verifyRelease.name} (ID: ${verifyRelease.id}, draft: ${verifyRelease.draft})`);

            core.setOutput('tag_name', tag);
            return data.id;

  build-nightly:
    needs: [check-commits, prepare-matrix, create-nightly-release]
    if: needs.check-commits.outputs.should_build == 'true'
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.prepare-matrix.outputs.matrix) }}

    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: apps/desktop -> apps/desktop/target

      - name: Setup Node.js environment
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache-dependency-path: pnpm-lock.yaml

      - uses: pnpm/action-setup@v4

      - name: Install apt dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-24.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-0=2.44.0-2 \
            libwebkit2gtk-4.1-dev=2.44.0-2 \
            libjavascriptcoregtk-4.1-0=2.44.0-2 \
            libjavascriptcoregtk-4.1-dev=2.44.0-2 \
            gir1.2-javascriptcoregtk-4.1=2.44.0-2 \
            gir1.2-webkit2-4.1=2.44.0-2 \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf

      - name: Install pnpm
        run: npm install -g pnpm

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: pnpm install

      - name: Update version with commit hash
        run: pnpm version:nightly ${{ needs.check-commits.outputs.latest_commit }}

      # Linux build - upload directly to release
      - name: Build the app (Linux)
        if: matrix.platform == 'ubuntu-24.04'
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          VITE_API_URL: https://api.deadlockmods.app
          VITE_WEB_URL: https://deadlockmods.app
          VITE_AUTH_URL: https://auth.deadlockmods.app
          VITE_GA_MEASUREMENT_ID: ${{ secrets.VITE_GA_MEASUREMENT_ID }}
        with:
          projectPath: ./apps/desktop
          releaseId: ${{ needs.create-nightly-release.outputs.release_id }}

      # Windows build - don't upload to release yet, need to code-sign first
      - name: Build the app (Windows)
        if: matrix.platform == 'windows-latest'
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          VITE_API_URL: https://api.deadlockmods.app
          VITE_WEB_URL: https://deadlockmods.app
          VITE_AUTH_URL: https://auth.deadlockmods.app
          VITE_GA_MEASUREMENT_ID: ${{ secrets.VITE_GA_MEASUREMENT_ID }}
        with:
          projectPath: ./apps/desktop
          args: "--bundles nsis,updater"

      # Windows: SignPath code signing flow
      - name: Sign Windows executables
        if: matrix.platform == 'windows-latest'
        id: signpath-sign
        uses: ./.github/actions/signpath-sign
        with:
          unsigned-artifact-path: apps/desktop/target/release/bundle/nsis/*.exe
          output-directory: ./artifact-output
          signpath-api-token: ${{ secrets.SIGNPATH_API_TOKEN }}
          signpath-organization-id: ${{ secrets.SIGNPATH_ORGANIZATION_ID }}
          signpath-project-slug: deadlock-mod-manager
          signpath-signing-policy: test-signing
          regenerate-tauri-signature: ${{ env.ENABLE_SIGNED_UPDATER }}
          tauri-private-key: ${{ secrets.TAURI_PRIVATE_KEY }}

      - name: Upload signed Windows artifact
        if: matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: windows-nightly-signed
          path: ./artifact-output/*
          if-no-files-found: error

      - name: Upload signed artifacts to release
        if: matrix.platform == 'windows-latest'
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ needs.create-nightly-release.outputs.release_id }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const releaseId = parseInt(process.env.RELEASE_ID);
            console.log(`Release ID from env: ${process.env.RELEASE_ID}`);
            console.log(`Parsed release ID: ${releaseId}`);

            // Verify the release exists before uploading
            try {
              const { data: release } = await github.rest.repos.getRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId
              });
              console.log(`Found release: ${release.name} (draft: ${release.draft})`);
            } catch (error) {
              console.error(`Failed to find release ${releaseId}: ${error.message}`);
              throw error;
            }

            const artifactDir = './artifact-output';
            const files = fs.readdirSync(artifactDir);
            console.log(`Files in artifact directory: ${JSON.stringify(files)}`);

            for (const file of files) {
              const filePath = path.join(artifactDir, file);
              const stats = fs.statSync(filePath);
              
              if (stats.isFile()) {
                // Sanitize filename - remove any trailing whitespace or special chars
                const sanitizedName = file.trim();
                console.log(`Uploading "${sanitizedName}" (original: "${file}") to release...`);
                console.log(`File size: ${stats.size} bytes`);
                const content = fs.readFileSync(filePath);
                
                try {
                  await github.rest.repos.uploadReleaseAsset({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: releaseId,
                    name: sanitizedName,
                    data: content
                  });
                  console.log(`Successfully uploaded ${sanitizedName}`);
                } catch (uploadError) {
                  console.error(`Upload failed for ${sanitizedName}`);
                  console.error(`Owner: ${context.repo.owner}, Repo: ${context.repo.repo}`);
                  console.error(`Release ID: ${releaseId}`);
                  console.error(`Error: ${uploadError.message}`);
                  if (uploadError.response) {
                    console.error(`Status: ${uploadError.response.status}`);
                    console.error(`Response data: ${JSON.stringify(uploadError.response.data)}`);
                  }
                  throw uploadError;
                }
              }
            }

  update-latest-json:
    needs: [check-commits, create-nightly-release, build-nightly]
    if: needs.check-commits.outputs.should_build == 'true' && vars.ENABLE_SIGNED_UPDATER == 'true'
    permissions:
      contents: write
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Windows signed artifact
        uses: actions/download-artifact@v4
        with:
          name: windows-nightly-signed
          path: release-artifacts/windows

      - name: Update latest.json
        uses: ./.github/actions/update-latest-json
        with:
          release-id: ${{ needs.create-nightly-release.outputs.release_id }}
          signed-artifact-path: ./release-artifacts/windows
          version: ${{ needs.create-nightly-release.outputs.tag_name }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

  publish-nightly:
    permissions:
      contents: write
    runs-on: ubuntu-latest
    needs:
      [check-commits, prepare-matrix, create-nightly-release, build-nightly]
    if: needs.check-commits.outputs.should_build == 'true'

    steps:
      - name: Publish nightly release
        uses: actions/github-script@v7
        env:
          release_id: ${{ needs.create-nightly-release.outputs.release_id }}
        with:
          script: |
            try {
              console.log(`Publishing nightly release ID: ${process.env.release_id}`);
              
              const { data: updatedRelease } = await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: process.env.release_id,
                draft: false,
                prerelease: true
              });
              
              console.log(`Successfully published nightly release: ${updatedRelease.html_url}`);
              return updatedRelease.id;
            } catch (error) {
              console.error(`Failed to publish nightly release: ${error.message}`);
              throw error;
            }

      - name: Cleanup old nightly releases
        uses: actions/github-script@v7
        with:
          script: |
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            const nightlyReleases = releases
              .filter(release => release.tag_name.startsWith('nightly-'))
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

            const releasesToDelete = nightlyReleases.slice(7);

            for (const release of releasesToDelete) {
              console.log(`Deleting old nightly release: ${release.tag_name}`);
              
              try {
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: release.id
                });
                
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${release.tag_name}`
                });
                
                console.log(`Successfully deleted ${release.tag_name}`);
              } catch (error) {
                console.error(`Failed to delete ${release.tag_name}: ${error.message}`);
              }
            }

  cleanup-nightly:
    permissions:
      contents: write
    runs-on: ubuntu-latest
    needs:
      [check-commits, prepare-matrix, create-nightly-release, build-nightly]
    if: failure() && needs.check-commits.outputs.should_build == 'true'

    steps:
      - name: Delete failed nightly release
        uses: actions/github-script@v7
        env:
          release_id: ${{ needs.create-nightly-release.outputs.release_id }}
        with:
          script: |
            if (process.env.release_id) {
              console.log(`Cleaning up failed nightly release: ${process.env.release_id}`);
              try {
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: process.env.release_id
                });
                console.log('Successfully cleaned up failed release');
              } catch (error) {
                console.error(`Cleanup failed: ${error.message}`);
              }
            }
